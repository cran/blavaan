functions {
  /*
    Fills in the elements of a coefficient matrix containing some mix of 
    totally free, free subject to a sign constraint, and fixed elements
    
    @param free_elements vector of unconstrained elements
    @param skeleton matrix of the same dimensions as the output whose elements are
      positive_infinity(): if output element is totally free
      other: if output element is fixed to that number
    @return matrix of coefficients
  */
  matrix fill_matrix(vector free_elements, matrix skeleton, int[,] eq_skeleton, int pos_start, int spos_start) {
    int R = rows(skeleton);
    int C = cols(skeleton);
    matrix[R, C] out;

    int pos = spos_start; // position of eq_skeleton
    int freepos = pos_start; // position of free_elements
    int eqelem = 0;
    
    for (c in 1:C) for (r in 1:R) {
      real rc = skeleton[r, c];
      if (is_inf(rc)) { // free
	int eq = eq_skeleton[pos, 1];
	int wig = eq_skeleton[pos, 3];
	if (eq == 0 || wig == 1) {
	  out[r,c] = free_elements[freepos];
	  freepos += 1;
	} else {
	  eqelem = eq_skeleton[pos, 2];
	  out[r,c] = free_elements[eqelem];
	}
	pos += 1;
      } else out[r,c] = skeleton[r, c]; // fixed, so do not bump pos
    }
    return out;
  }
    
  vector fill_prior(vector free_elements, real[] pri_mean, int[,] eq_skeleton) {
    int R = size(eq_skeleton);
    int eqelem = 0;
    int pos = 1;
    vector[num_elements(pri_mean)] out;

    for (r in 1:R) {
      if (pos <= num_elements(pri_mean)) {
	int eq = eq_skeleton[r, 1];
	int wig = eq_skeleton[r, 3];

	if (eq == 0) {
	  out[pos] = pri_mean[pos];
	  pos += 1;
	} else if (wig == 1) {
	  eqelem = eq_skeleton[r, 2];
	  out[pos] = free_elements[eqelem];
	  pos += 1;
	}
      }
    }
    return out;
  }
  
  /*
   * This is a bug-free version of csr_to_dense_matrix and has the same arguments
   */
  matrix to_dense_matrix(int m, int n, vector w, int[] v, int[] u) {
    matrix[m, n] out = rep_matrix(0, m, n);
    int pos = 1;
    for (i in 1:m) {
      int start = u[i];
      int nnz = u[i + 1] - start;
      for (j in 1:nnz) {
        out[i, v[pos]] = w[pos];
        pos += 1;
      }
    }
    return out;
  }

  // sign function
  int sign(real x) {
    if (x > 0)
      return 1;
    else
      return -1;
  }
}
data {
  int<lower=0> p; // number of manifest response variables
  int<lower=0> q; // number of manifest predictors
  int<lower=1> Ntot; // number of observations across all groups
  vector[p + q] YX[Ntot];
  int<lower=0, upper=1> ord; // is there y variable binary?
  
  /* sparse matrix representations of skeletons of coefficient matrices, 
     which is not that interesting but necessary because you cannot pass
     missing values into the data block of a Stan program from R */
  // same things but for B
  int<lower=0> len_w4;
  int<lower=0> wg4[Ng];
  vector[len_w4] w4[Ng];
  int<lower=1> v4[Ng, len_w4];
  int<lower=1> u4[Ng, m + 1];
  int<lower=0> w4skel[sum(wg4), 3];
  int<lower=0> b_sign[sum(wg4), 3];
  int<lower=0> len_b;
  real b_mn[len_b];
  real<lower=0> b_sd[len_b];
  
  // same things but for Psi
  int<lower=0> len_w9;
  int<lower=0> wg9[Ng];
  vector[len_w9] w9[Ng];
  int<lower=1> v9[Ng, len_w9];
  int<lower=1> u9[Ng, m + 1];
  int<lower=0> w9skel[sum(wg9), 3];
  int<lower=0> len_psi_sd;
  real<lower=0> psi_sd_shape[len_psi_sd];
  real<lower=0> psi_sd_rate[len_psi_sd];
  int<lower=-2,upper=2> psi_pow;
  int<lower=0> w9use;
  int<lower=1> usepsi[w9use];
  int<lower=0> w9no;
  int<lower=1> nopsi[w9no];
  
  // same things but for Alpha
  int<lower=0> len_w14;
  int<lower=0> wg14[Ng];
  vector[len_w14] w14[Ng];
  int<lower=0> v14[Ng, len_w14];
  int<lower=1> u14[Ng, m + n + 1];
  int<lower=0> w14skel[sum(wg14), 3];
  int<lower=0> len_alph;
  real alpha_mn[len_alph];
  real<lower=0> alpha_sd[len_alph];

  // same things but for Tau
  int<lower=0> len_w15;
  int<lower=0> wg15[Ng];
  vector[len_w15] w15[Ng];
  int<lower=0> v15[Ng, len_w15];
  int<lower=1> u15[Ng, sum(nlevs) - Nord + 1];
  int<lower=0> w15skel[sum(wg15), 3];
  int<lower=0> len_tau;
  real tau_mn[len_tau];
  real<lower=0> tau_sd[len_tau];
}
transformed data { // (re)construct skeleton matrices in Stan (not that interesting)
  matrix[m, m] B_skeleton[Ng];
  matrix[m, m] Psi_skeleton[Ng];
  matrix[(m + n), 1] Alpha_skeleton[Ng];
  matrix[sum(nlevs) - Nord, 1] Tau_skeleton[Ng];
  
  int g_start4[Ng];
  int g_start9[Ng];
  int g_start14[Ng];
  int g_start15[Ng];
  
  int f_start4[Ng];
  int f_start9[Ng];
  int f_start14[Ng];
  int f_start15[Ng];
  
  int len_free[4];
  int pos[4];
  
  for (i in 1:4) {
    len_free[i] = 0;
    pos[i] = 1;
  }
  
  for (g in 1:Ng) {
    B_skeleton[g] = to_dense_matrix(m, m, w4[g], v4[g,], u4[g,]);
    Psi_skeleton[g] = to_dense_matrix(m, m, w9[g], v9[g,], u9[g,]);
    Alpha_skeleton[g] = to_dense_matrix((m + n), 1, w14[g], v14[g,], u14[g,]);
    Tau_skeleton[g] = to_dense_matrix(sum(nlevs) - Nord, 1, w15[g], v15[g,], u15[g,]);
    
    // same thing but for B_skeleton
    g_start4[g] = len_free[1] + 1;
    f_start4[g] = pos[1];
    for (i in 1:m) {
      for (j in 1:m) {
	if (is_inf(B_skeleton[g,i,j])) {
	  if (w4skel[pos[1],2] == 0 || w4skel[pos[1],3] == 1) len_free[1] += 1;
	  pos[1] += 1;
	}
      }
    }
    
    // same thing but for Psi_skeleton
    g_start9[g] = len_free[2] + 1;
    f_start9[g] = pos[2];
    for (i in 1:m) {
      if (is_inf(Psi_skeleton[g,i,i])) {
	if (w9skel[pos[2],2] == 0 || w9skel[pos[2],3] == 1) len_free[2] += 1;
	pos[2] += 1;
      }
    }

    // same thing but for Alpha_skeleton
    g_start14[g] = len_free[3] + 1;
    f_start14[g] = pos[3];
    for (i in 1:(m+n)) {
      if (is_inf(Alpha_skeleton[g,i,1])) {
	if (w14skel[pos[3],2] == 0 || w14skel[pos[3],3] == 1) len_free[3] += 1;
	pos[3] += 1;
      }
    }

    // same thing but for Tau_skeleton
    g_start15[g] = len_free[4] + 1;
    f_start15[g] = pos[4];
    for (i in 1:(sum(nlevs) - Nord)) { \\FIXME
      if (is_inf(Tau_skeleton[g,i,1])) {
	if (w15skel[pos[4],2] == 0 || w15skel[pos[4],3] == 1) len_free[4] += 1;
	pos[4] += 1;
      }
    }    
  }
}
parameters {
  // free elements (possibly with inequality constraints) for coefficient matrices
  vector[len_free[1]] B_free;
  vector<lower=0>[len_free[2]] Psi_sd_free;
  vector[len_free[3]] Alpha_free;
  vector[len_free[4]] Tau_ufree; // FIXME change to ordered
}
transformed parameters {
  matrix[m, m] B[Ng];
  matrix[m + n, 1] Alpha[Ng];
  
  matrix[m, m] Psi_sd[Ng];
  vector[len_free[1]] b_primn;
  vector[len_free[3]] alpha_primn;
  vector[len_free[4]] tau_primn;

  for (g in 1:Ng) {
    // model matrices
    B[g] = fill_matrix(B_free, B_skeleton[g], w4skel, g_start4[g], f_start4[g]);
    Alpha[g] = fill_matrix(Alpha_free, Alpha_skeleton[g], w14skel, g_start14[g], f_start14[g]);

    Psi[g] = fill_matrix(Psi_sd_free, Psi_skeleton[g], w9skel, g_start9[g], f_start9[g]);
  }

  // prior vectors
  if (wigind) {
    b_primn = fill_prior(B_free, b_mn, w4skel);
    alpha_primn = fill_prior(Alpha_free, alpha_mn, w14skel);
    tau_primn = fill_prior(Tau_ufree, tau_mn, w15skel); // FIXME
  } else {
    b_primn = to_vector(b_mn);
    alpha_primn = to_vector(alpha_mn);
    tau_primn = to_vector(tau_mn);
  }
}
model { // N.B.: things declared in the model block do not get saved in the output, which is okay here

  /* transformed sd parameters for priors */
  vector[len_free[2]] Psi_pri;
  
  /* log-likelihood */
  if (ord) {

  } else {

  }
  
  /* prior densities in log-units */
  target += normal_lpdf(B_free        | b_primn, b_sd);
  target += normal_lpdf(Alpha_free    | alpha_primn, alpha_sd);
  target += normal_lpdf(Tau_ufree      | tau_primn, tau_sd); // FIXME

  /* transform sd parameters to var or prec, depending on
     what the user wants. */
  Psi_pri = Psi_sd_free;
  if (len_free[2] > 0 && psi_pow != 1) {
    for (i in 1:len_free[2]) {
      Psi_pri[i] = Psi_sd_free[i]^(psi_pow);
      target += log(fabs(psi_pow)) + (psi_pow - 1)*log(Psi_sd_free[i]);
    }
  }
  target += gamma_lpdf(Psi_pri | psi_sd_shape, psi_sd_rate);
}
generated quantities {
  // sign constraints and correlations
  vector[len_free[2]] Psi_var;

  vector[Ntot] log_lik; // for loo, etc
  vector[Ntot] log_lik_sat; // for ppp
  vector[p + q] YXstar_rep[Ntot]; // artificial data
  vector[Ntot] log_lik_rep; // for loo, etc
  vector[Ntot] log_lik_rep_sat; // for ppp
  matrix[p + q, p + q + 1] satout[Ng];
  matrix[p + q, p + q + 1] satrep_out[Ng];
  vector[p + q] Mu_sat[Ng];
  matrix[p + q, p + q] Sigma_sat[Ng];
  matrix[p + q, p + q] Sigma_sat_inv_grp[Ng];
  real logdetS_sat_grp[Ng];
  matrix[p + q + 1, p + q + 1] Sigma_sat_inv[Np];
  vector[p + q] Mu_rep_sat[Ng];
  matrix[p + q, p + q] Sigma_rep_sat[Ng];
  matrix[p + q, p + q] Sigma_rep_sat_inv_grp[Ng];
  matrix[p + q + 1, p + q + 1] Sigma_rep_sat_inv[Np];
  real logdetS_rep_sat_grp[Ng];
  matrix[p + q, p + q] zmat;
  real<lower=0, upper=1> ppp;
  
  // first deal with sign constraints:
  ly_sign = sign_constrain_load(Lambda_y_free, len_free[1], lam_y_sign);
  bet_sign = sign_constrain_reg(B_free, len_free[4], b_sign, Lambda_y_free, Lambda_y_free);
  if (fullpsi == 0) {
    P_r = sign_constrain_reg(2 * Psi_r_free - 1, len_free[10], psi_r_sign, Lambda_y_free, Lambda_y_free);
  }
  
  for (g in 1:Ng) {
    L_Y[g] = fill_matrix(ly_sign, Lambda_y_skeleton[g], w1skel, g_start1[g], f_start1[g]);

    Gam[g] = fill_matrix(g_sign, Gamma_skeleton[g], w3skel, g_start3[g], f_start3[g]);

    Bet[g] = fill_matrix(bet_sign, B_skeleton[g], w4skel, g_start4[g], f_start4[g]);

    Theta[g] = quad_form_sym(Theta_r[g], Theta_sd[g]);

    if (m > 0) {
      if (fullpsi) {
	PSmat[g] = Psi_r_mat[g];
	PS[g] = quad_form_sym(PSmat[g], Psi_sd[g]);
      } else {
	PSmat[g] = fill_matrix(P_r, Psi_r_skeleton[g], w10skel, g_start10[g], f_start10[g]);
	PS[g] = quad_form_sym(PSmat[g] + transpose(PSmat[g]) - diag_matrix(rep_vector(1, m)), Psi_sd[g]);
      }

    }
    
  }

  // off-diagonal covariance parameter vectors, from cor/sd matrices:
  Theta_cov = cor2cov(Theta_r, Theta_sd, num_elements(Theta_r_free), Theta_r_skeleton, w7skel, Ng);
  Theta_var = Theta_sd_free .* Theta_sd_free;
  if (m > 0 && len_free[10] > 0) {
    /* iden is created so that we can re-use cor2cov, even though
       we don't need to multiply to get covariances */
    matrix[m, m] iden[Ng];
    for (g in 1:Ng) {
      iden[g] = diag_matrix(rep_vector(1, m));
    }
    Psi_cov = cor2cov(PS, iden, len_free[10], Psi_r_skeleton, w10skel, Ng);
  } else {
    Psi_cov = P_r;
  }
  Psi_var = Psi_sd_free .* Psi_sd_free;

  { // log-likelihood
    int obsidx[p + q];
    int xidx[p + q];
    int xdatidx[p + q];
    int r1;
    int r2;
    int grpidx;

    if (do_test) {
      for (mm in 1:Np) {
	obsidx = Obsvar[mm,];
	xidx = Xvar[mm,];
	xdatidx = Xdatvar[mm,];
	r1 = startrow[mm];
	r2 = endrow[mm];
	grpidx = grpnum[mm];
	for (jj in r1:r2) {
	  YXstar_rep[jj, 1:Nobs[mm]] = multi_normal_rng(Mu[grpidx, obsidx[1:Nobs[mm]]], Sigma[grpidx, obsidx[1:Nobs[mm]], obsidx[1:Nobs[mm]]]);
	}
      }

      if (missing) {
	// start values for Mu and Sigma
	for (g in 1:Ng) {
	  Mu_sat[g] = rep_vector(0, p + q);
	  Mu_rep_sat[g] = Mu_sat[g];
	  Sigma_sat[g] = diag_matrix(rep_vector(1, p + q));
	  Sigma_rep_sat[g] = Sigma_sat[g];
	}

	for (jj in 1:emiter) {
	  satout = estep(YXstar, Mu_sat, Sigma_sat, Nobs, Obsvar, startrow, endrow, grpnum, Np, Ng);
	  satrep_out = estep(YXstar_rep, Mu_rep_sat, Sigma_rep_sat, Nobs, Obsvar, startrow, endrow, grpnum, Np, Ng);

	  // M step
	  for (g in 1:Ng) {
	    Mu_sat[g] = satout[g,,1]/N[g];
	    Sigma_sat[g] = satout[g,,2:(p + q + 1)]/N[g] - Mu_sat[g] * Mu_sat[g]';
	    Mu_rep_sat[g] = satrep_out[g,,1]/N[g];
	    Sigma_rep_sat[g] = satrep_out[g,,2:(p + q + 1)]/N[g] - Mu_rep_sat[g] * Mu_rep_sat[g]';
	  }
	}
      } else {
	// complete data; Np patterns must only correspond to groups
	for (mm in 1:Np) {
	  int arr_dims[3] = dims(YXstar);
	  matrix[endrow[mm] - startrow[mm] + 1, arr_dims[2]] YXsmat; // crossprod needs matrix
	  matrix[endrow[mm] - startrow[mm] + 1, arr_dims[2]] YXsrepmat;
	  r1 = startrow[mm];
	  r2 = endrow[mm];
	  grpidx = grpnum[mm];
	  for (jj in 1:(p + q)) {
	    Mu_sat[grpidx,jj] = mean(YXstar[r1:r2,jj]);
	    Mu_rep_sat[grpidx,jj] = mean(YXstar_rep[r1:r2,jj]);
	  }
	  for (jj in r1:r2) {
	    YXsmat[jj - r1 + 1] = (YXstar[jj] - Mu_sat[grpidx])';
	    YXsrepmat[jj - r1 + 1] = (YXstar_rep[jj] - Mu_rep_sat[grpidx])';
	  }
	  Sigma_sat[grpidx] = crossprod(YXsmat)/N[grpidx];
	  Sigma_rep_sat[grpidx] = crossprod(YXsrepmat)/N[grpidx];
	  // FIXME? Sigma_sat[grpidx] = tcrossprod(YXsmat); does not throw an error??
	}
      }

      for (g in 1:Ng) {
	Sigma_sat_inv_grp[g] = inverse_spd(Sigma_sat[g]);
	logdetS_sat_grp[g] = log_determinant(Sigma_sat[g]);

	Sigma_rep_sat_inv_grp[g] = inverse_spd(Sigma_rep_sat[g]);
	logdetS_rep_sat_grp[g] = log_determinant(Sigma_rep_sat[g]);
      }

      for (mm in 1:Np) {
	Sigma_sat_inv[mm, 1:(Nobs[mm] + 1), 1:(Nobs[mm] + 1)] = sig_inv_update(Sigma_sat_inv_grp[grpnum[mm]], Obsvar[mm,], Nobs[mm], p + q, logdetS_sat_grp[grpnum[mm]]);
	Sigma_rep_sat_inv[mm, 1:(Nobs[mm] + 1), 1:(Nobs[mm] + 1)] = sig_inv_update(Sigma_rep_sat_inv_grp[grpnum[mm]], Obsvar[mm,], Nobs[mm], p + q, logdetS_rep_sat_grp[grpnum[mm]]);
      }
    }
    
    // compute log-likelihoods
    zmat = rep_matrix(0, p + q, p + q);
    for (mm in 1:Np) {
      obsidx = Obsvar[mm,];
      xidx = Xvar[mm,];
      xdatidx = Xdatvar[mm,];
      r1 = startrow[mm];
      r2 = endrow[mm];
      grpidx = grpnum[mm];
      
      for (jj in r1:r2) {
	log_lik[jj] = multi_normal_suff(YXstar[jj, 1:Nobs[mm]], zmat[1:Nobs[mm], 1:Nobs[mm]], Mu[grpidx, obsidx[1:Nobs[mm]]], Sigmainv[mm], 1);
	if (do_test) {
	  // we add loglik[jj] here so that _sat always varies and does not lead to
	  // problems with rhat and neff computations
	  log_lik_sat[jj] = -log_lik[jj] + multi_normal_suff(YXstar[jj, 1:Nobs[mm]], zmat[1:Nobs[mm], 1:Nobs[mm]], Mu_sat[grpidx, obsidx[1:Nobs[mm]]], Sigma_sat_inv[mm], 1);
	
	  log_lik_rep[jj] = multi_normal_suff(YXstar_rep[jj, 1:Nobs[mm]], zmat[1:Nobs[mm], 1:Nobs[mm]], Mu[grpidx, obsidx[1:Nobs[mm]]], Sigmainv[mm], 1);
	  log_lik_rep_sat[jj] = multi_normal_suff(YXstar_rep[jj, 1:Nobs[mm]], zmat[1:Nobs[mm], 1:Nobs[mm]], Mu_rep_sat[grpidx, obsidx[1:Nobs[mm]]], Sigma_rep_sat_inv[mm], 1);
	} else {
	  log_lik_sat[jj] = 0;
	}

	// log_lik_sat, log_lik_sat_rep
	if (Nx[mm] > 0) {
	  log_lik[jj] += -multi_normal_suff(YXstar[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), 1);
	  if (do_test) {
	    log_lik_sat[jj] += multi_normal_suff(YXstar[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), 1);
	    log_lik_sat[jj] += -multi_normal_suff(YXstar[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu_sat[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigma_sat_inv[grpidx], xidx, Nx[mm], p + q, logdetS_sat_grp[grpidx]), 1);
	  
	    log_lik_rep[jj] += -multi_normal_suff(YXstar_rep[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), 1);

	    log_lik_rep_sat[jj] += -multi_normal_suff(YXstar_rep[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu_rep_sat[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigma_rep_sat_inv[grpidx], xidx, Nx[mm], p + q, logdetS_rep_sat_grp[grpidx]), 1);
	  }
	}
      }
    }

    // for ppp, compare observed log_lik vs rep log_lik
    if (do_test) {
      ppp = step((-sum(log_lik_rep) + sum(log_lik_rep_sat)) - (sum(log_lik_sat)));
    } else {
      ppp = 0;
    }
  }
  
} // end with a completely blank line (not even whitespace)
